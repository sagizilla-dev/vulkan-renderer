#version 460

#extension GL_NV_mesh_shader : require
#extension GL_EXT_shader_8bit_storage: require
// this extension allows the use of 8-bit integer types for arithmetic operations
#extension GL_EXT_shader_explicit_arithmetic_types: require

#include "common.h"

layout(local_size_x = 32) in;
layout(triangles) out;
// we use 126 primitives since hardware allocates primitive indices in 128 byte granularity and needs
// to reserve 4 bytes for the primitive count
// therefore 3*126+4 maximizes the fit into 128*3 bytes block
// going beyond 126 allocates the next 128 bytes
layout(max_vertices = 64, max_primitives = 124) out;

layout(set = 0, binding = 0) uniform MVP {
    mat4 model;
    mat4 view;
    mat4 proj;
} mvp;


layout(set = 0, binding = 2) readonly buffer Vertices {
    Vertex vertices[];
};

layout(set = 0, binding = 3) readonly buffer Meshlets {
    Meshlet meshlets[];
};

layout(set = 0, binding = 4) readonly buffer MeshletData {
    uint meshletData[];
};

// this block is passed from the task shader and is shared between 31 other mesh workgroups
// each mesh workgroup picks its meshlet index based on its workgroup ID
// this meshlet index leads to a global buffer of meshlets, so the range of values here
// is [0, meshletCount)
in taskNV block {
    uint meshletIndices[32];
};

layout(location = 0) out vec3 Normal[];
layout(location = 1) out vec2 TexCoords[];

vec3 meshletColor(uint meshletIndex) {
    float hue = fract(float(meshletIndex) * 0.618033988749895);
    vec3 c = vec3(hue * 6.0);
    vec3 k = mod(c + vec3(0.0, 4.0, 2.0), 6.0);
    vec3 p = abs(k - 3.0);
    vec3 rgb = vec3(0.9) - 0.7 * clamp(p - 1.0, 0.0, 1.0);
    return rgb;
}

void main() {
    // important note here is that task shaders dispatch mesh shaders independently
    // i.e if one task shader dispatches 32 mesh workgroups, then the range of gl_WorkGroupID.x is [0, 31]
    // meanwhile when the second task shader dispatches another 32 mesh workgroups, the range is also [0, 31]
    uint meshletID = meshletIndices[gl_WorkGroupID.x];
    uint tid = gl_LocalInvocationID.x;
    
    // each thread must process a vertex
    for (uint i = tid; i < meshlets[meshletID].vertexCount; i+=32) {
        uint32_t globalVertexID = meshletData[meshlets[meshletID].dataOffset+i]; 

        // vertices array for a meshlet
        gl_MeshVerticesNV[i].gl_Position = mvp.proj * mvp.view * mvp.model * 
            vec4(vertices[globalVertexID].vx, 
                vertices[globalVertexID].vy,
                vertices[globalVertexID].vz, 1.0);

        vec3 decompressed = vec3(vertices[globalVertexID].nx, vertices[globalVertexID].ny, vertices[globalVertexID].nz) / 255.0 * 2.0 - 1.0;
        // Normal[i] = decompressed;
        Normal[i] = meshletColor(meshletID);

        TexCoords[i] = vec2(vertices[globalVertexID].tu, vertices[globalVertexID].tv);
    }

    // we use writePackedPrimitiveIndices4x8NV(...) to write 4 primitive indices at once from 
    // a packed uint32_t into gl_PrimitiveIndicesNV
    // we need to round up the number of indices though, i.e
    // if we have 123*3 = 369 uint8_t indices, they are packed into 92 uint32_t indices and 1 uint8_t index
    // but we need unit32_t to operate with writePackedPrimitiveIndices4x8NV, so we must round up the number of packed
    // indices to 93
    uint packedIndexCount = (meshlets[meshletID].triangleCount*3+3)/4;
    for (uint i = tid; i < packedIndexCount; i+=32) {
        // offset is the offset within gl_PrimitiveIndicesNW
        // these indices are local, they refer to gl_MeshVerticesNV, not the global vertex buffer
        writePackedPrimitiveIndices4x8NV(i*4, meshletData[meshlets[meshletID].dataOffset+meshlets[meshletID].vertexCount+i]);
    }

    if (tid==0) {
        // number of primitives outputted
        gl_PrimitiveCountNV = meshlets[meshletID].triangleCount;
    }
}
