#version 460

#extension GL_NV_mesh_shader : require
#extension GL_EXT_shader_8bit_storage: require
#extension GL_EXT_shader_explicit_arithmetic_types: require
// subgroup is essentially a warp
#extension GL_KHR_shader_subgroup_ballot: require
#extension GL_ARB_shader_draw_parameters: require

#include "common.h"

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform block {
    Globals globals;
};

layout(set = 0, binding = 4) readonly buffer Transforms {
    Transform transforms[];
};

layout(set = 0, binding = 2) readonly buffer Meshlets {
    Meshlet meshlets[];
};

layout(set = 0, binding = 5) uniform sampler2D hiZPyramidSampler;

out taskNV block {
    // those are indices of meshlets that are not culled
    // note that this array must be filled with values in a contiguous order, i.e there must be no gaps of garbage data
    uint meshletIndices[32];
    // so for some reason validation layers do not allow mesh shaders to use gl_DrawID if task shader is bound, so we
    // just pass drawID directly from the task shader
    uint drawID;
};

bool coneCull(vec3 coneAxis, float coneW, vec3 cameraPos, vec3 coneApex) {
    // view direction comes from cone apex to camera
    vec3 viewDirection = normalize(cameraPos - coneApex);
    return dot(coneAxis, viewDirection) < -coneW;
}

bool frustumCull(vec3 coneApex, float radius) {
    for (int i=0; i<5; i++) {
        // plane equation is Nx*Px + Ny*Py + Nz*Pz = d for a point P
        // so if a point satisfies the equation Nx*Px + Ny*Py + Nz*Pz - d = 0.0, it means it is on the plane
        // if it is < 0.0, it is behind the plane
        // if it is > 0.0, it is in front of the plane, in normal's direction space
        // even if the center is behind the plane, we need to account for the furthest point on the sphere, so
        // we must add radius
        if (dot(globals.frustum[i].xyz, coneApex) + globals.frustum[i].w + radius < 0.0) {
            return true;
        }
    }
    return false;
}

bool occlusionCull(vec3 coneApex, float radius) {
    // now the coordinates are in clip space, with .w component storing -z value
    vec4 clipPosition = globals.proj * globals.view * vec4(coneApex, 1.0);
    // convert to normalized device coordinates
    vec3 ndcPosition = clipPosition.xyz/clipPosition.w;
    float ndcRadius = (globals.proj[1][1]*radius)/clipPosition.w;
    // texture coordinates of the apex
    vec2 uv = ndcPosition.xy * 0.5 + 0.5; // convert ndc coordinates from [-1, 1] to [0, 1];
    uv.y = 1.0 - uv.y;

    vec2 texSize = vec2(textureSize(hiZPyramidSampler, 0));
    float screenPixels = ndcRadius * 2.0 * max(texSize.x, texSize.y); // how many pixels the bounding sphere occupies
    // get the mip level where the entire bounding sphere is occupied by 1 pixel
    float mipLevel = ceil(log2(max(screenPixels, 1.0)));
    mipLevel = clamp(mipLevel, 0.0, float(textureQueryLevels(hiZPyramidSampler)-1));

    float sampledDepth = textureLod(hiZPyramidSampler, uv, mipLevel).r;
    // is this correct? what if coneApex + radius is actually visible?
    return ndcPosition.z < sampledDepth - 0.05; // subtract bias to account for pixel vs sphere comparison
}

void main() {
    uint localMeshletID = gl_WorkGroupID.x; // meshlets batch index
    uint tid = gl_LocalInvocationID.x; // meshlet index within the batch
    uint meshletID = localMeshletID*32 + tid; // global meshlet ID
    Transform transform = transforms[gl_DrawIDARB];
    bool accept = false;
    if (meshletID < globals.meshletCount) {
        // if we inverse the view matrix, we can get the camera position in the world space
        // by accessing the last row
        mat4 invView = inverse(globals.view);
        vec3 cameraPos = vec3(invView[3][0], invView[3][1], invView[3][2]);
        // cone apex must be translated into world coordinates
        vec3 coneApex = vec3(transform.model * vec4(meshlets[meshletID].coneApex.xyz, 1.0));
        // cone axis must be translated into world coordinates as well
        // although we need to ignore translation this time since axis is a vector
        // which has no position
        vec3 coneAxis = normalize(mat3(transform.model) * meshlets[meshletID].cone.xyz);
        // get the cone spread as -sin(A)
        float coneW = meshlets[meshletID].cone.w;
        // radius must be scaled into world coordinates
        float radius = meshlets[meshletID].radius * length(transform.model[0].xyz);
        
        accept = !frustumCull(coneApex, radius) && !occlusionCull(coneApex, radius) && !coneCull(coneAxis, coneW, cameraPos, coneApex);
    }
    // ballot is a bitmask where each bit represents one thread's boolean value
    // this function creates the bitmask based on the variable provided
	uvec4 ballot = subgroupBallot(accept);
    // this function counts how many 1 bits are before the current thread's position
    uint index = subgroupBallotExclusiveBitCount(ballot);
    // so if this thread didn't cull its meshlet, we store this meshlet's global ID at the appropriate
    // position, which is defined by how many threads are supposed to write at the positions before
    if (accept) {
        meshletIndices[index] = meshletID;
    }
    // now we just count the total number of 1 bits in the ballot
    uint count = subgroupBallotBitCount(ballot);
    if (tid==0) {
        drawID = gl_DrawIDARB;
        gl_TaskCountNV = count; // this defines how many mesh shaders/workgroups to dispatch from this task shader
    }
}